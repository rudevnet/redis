# Часто задаваемые вопросы о Redis

Часто задаваемые вопросы в начале работы с Redis

---

## Чем Redis отличается от других хранилищ ключ-значение?

* Redis имеет другой путь эволюции в базах данных типа "ключ-значение", где значения могут содержать более сложные типы данных с атомарными операциями, определенными для этих типов данных. Типы данных Redis тесно связаны с фундаментальными структурами данных и предоставляются программисту как таковые, без дополнительных слоев абстракции.
* Redis - это база данных в памяти, но постоянно хранящаяся на диске, поэтому она представляет собой другой компромисс, когда достигается очень высокая скорость записи и чтения с ограничением наборов данных, которые не могут быть больше памяти. Еще одним преимуществом
баз данных в памяти является то, что представлением в памяти сложных структур данных
намного проще управлять по сравнению с теми же структурами данных на диске, поэтому
Redis может многое сделать с небольшой внутренней сложностью. В то же время
два формата хранения на диске (RDB и AOF) не обязательно должны быть пригодны для произвольного
доступа, поэтому они компактны и всегда генерируются только в режиме добавления
(Даже ротация журнала AOF является операцией только добавления, так как новая версия
генерируется из копии данных в памяти). Однако этот дизайн также связан с
другими проблемами по сравнению с традиционными хранилищами на диске. Будучи основным представлением
данных в памяти, операции Redis должны тщательно обрабатываться,
чтобы всегда иметь обновленную версию набора данных на диске.

## Сколько памяти необходимо Redis?

Вот вам несколько примеров (все они получены с использованием 64-битных экземпляров):

* Пустой экземпляр использует ~ 3MB памяти.
* 1 миллион небольших пар значений Keys -> String использует ~ 85MB памяти.
* 1 миллион значений Keys -> Hash, представляющих объект с 5 полями, использует ~ 160 MB памяти.

Тестирование вашего варианта использования тривиально. Используйте утилиту `redis-benchmark` для создания случайных наборов данных, а затем проверьте используемое пространство с помощью команды `INFO memory`.

64-разрядные системы будут использовать значительно больше памяти, чем 32-разрядные системы, для хранения одних и тех же ключей, особенно если ключи и значения имеют небольшой размер. Это связано с тем, что указатели занимают 8 байтов в 64-битных системах. Но, конечно, преимущество в том, что у вас может быть
много памяти в 64-битных системах, поэтому для запуска больших серверов Redis более или менее требуется 64-битная система. Альтернатива - шардинг.

## Почему Redis хранит весь свой набор данных в памяти?

В прошлом разработчики Redis экспериментировали с виртуальной памятью и другими системами, чтобы позволить наборы данных больше, чем RAM, но, в конце концов, мы очень счастливы, если можем сделать что-то хорошо: данные обслуживаются из памяти, а диск используется для хранения. Поэтому на данный момент нет планов по созданию серверной части для Redis на диске. В конце концов, большая часть того,
чем является Redis, является прямым результатом его текущего дизайна.

Если ваша реальная проблема заключается не в общем объеме необходимой оперативной памяти, а в том, что вам нужно
разделить набор данных на несколько экземпляров Redis, ознакомьтесь с дополнительной информацией на
[странице разделения](../management/scaling.md) в этой документации.

Redis Ltd., компания, спонсирующая разработку Redis, разработала решение
"Redis на флэш-памяти"(Redis on Flash), в котором используется смешанный подход ОЗУ и флэш-памяти для
больших наборов данных с предвзятым шаблоном доступа. Вы можете проверить их предложение
для получения дополнительной информации, однако эта функция не является частью базы кода Redis
с открытым исходным кодом.

## Можно ли использовать Redis с базой данных на диске?

Да, распространенный шаблон проектирования включает в себя перенос небольших данных
с большим объемом записи в Redis (и данные, которые вам нужны в структурах данных Redis для эффективного моделирования
вашей проблемы) и большие *блоки* данных в SQL или, в конечном итоге,
в согласованную базу данных на диске. Точно так же иногда Redis используется для того, чтобы
взять в память другую копию подмножества тех же данных, хранящихся в базе данных
на диске. Это может выглядеть похоже на кэширование, но на самом деле это более продвинутая модель,
поскольку обычно набор данных Redis обновляется вместе с набором данных БД на диске,
а не обновляется при промахах кэша.

## Как я могу уменьшить общее использование памяти Redis?

Если можете, используйте 32-битные экземпляры Redis. Также хорошо подойдет использование небольших hashes,
lists, sorted sets, и sets из целых чисел, поскольку Redis может представлять
эти типы данных, в особом случае из нескольких элементов, гораздо более компактным
способом. Дополнительная информация находится на [странице оптимизации памяти](../management/optimization/memory-optimization.md).

## Что произойдет, если у Redis закончится память?

Redis имеет встроенную защиту, позволяющую пользователям устанавливать максимальное ограничение на использование
памяти, используя параметр `maxmemory` в файле конфигурации, чтобы установить ограничение
на объем памяти, который может использовать Redis. Если этот предел будет достигнут, Redis начнет отвечать
ошибкой на команды записи (но продолжит принимать команды только
для чтения).

Вы также можете настроить Redis для удаления ключей при достижении максимального предела
памяти. Дополнительную информацию об этом см. в [документе политики удаления](../reference/eviction/index.md).

## Сбой фонового сохранения с ошибкой fork() в Linux?

Краткий ответ: `echo 1 > /proc/sys/vm/overcommit_memory` :)

А теперь длинный:

Схема фонового сохранения Redis основана на семантике копирования-при-записи системного вызова `fork` в
современных операционных системах: Redis разветвляется (создает дочерний процесс), который является
точной копией родителя. Дочерний процесс сбрасывает БД на диск и, наконец, завершает
работу. В теории, дочерний процесс должен использовать столько же памяти, сколько и родитель, являющийся
копией, но на самом деле благодаря семантике копирования-при-записи, реализованной в большинстве
современных операционных систем, родительский и дочерний процессы будут _совместно_ использовать общие
страницы памяти. Страница будет дублироваться только при ее изменении в дочернем или
в родительском процессе. Поскольку теоретически все страницы могут изменяться во время сохранения
дочерним процессом, Linux не может заранее сказать, сколько памяти займет дочерний процесс, поэтому, если
для параметра `overcommit_memory` установлено значение 0, разветвление не удастся, если не будет
столько свободной оперативной памяти сколько требуется, чтобы действительно дублировать все родительские страницы памяти.
Если у вас есть набор данных Redis размером 3 ГБ и всего 2 ГБ свободной
памяти, произойдет сбой.

Установка `overcommit_memory` в 1 говорит Linux расслабиться и выполнить разветвление
более оптимистичным способом распределения, и это действительно то, что вы хотите для Redis.

Вы можете обратиться к справочной странице [proc(5)][proc5] для объяснения
доступных значений.

[proc5]: http://man7.org/linux/man-pages/man5/proc.5.html

## Являются ли моментальные снимки Redis на диске атомарными?

Да, процесс фонового сохранения Redis всегда разветвляется, когда сервер
не выполняет команду, поэтому каждая команда, которая считается атомарной
в ОЗУ, также является атомарной с точки зрения моментального снимка диска.

## Как Redis может использовать несколько процессоров или ядер?

ЦП не очень часто становится вашим узким местом с Redis, поскольку обычно Redis привязан либо к памяти, либо к сети.
Например, при использовании пайплайнов экземпляр Redis, работающий в средней системе Linux, может доставлять 1 миллион запросов в секунду, поэтому, если ваше приложение в основном использует команды O(N) или O(log (N)), оно вряд ли будет использовать слишком много ресурсов ЦП.

Однако, чтобы максимизировать использование ЦП, вы можете запустить несколько экземпляров Redis на
одной машине и рассматривать их как разные серверы. В какой-то момент одной
машины все равно может быть недостаточно, поэтому, если вы хотите использовать несколько процессоров, вы можете
заранее начать думать о каком-то способе шардирования.

Дополнительную информацию об использовании нескольких экземпляров Redis можно найти на [странице разделения](../management/scaling.md).

Начиная с версии 4.0 Redis начал реализовывать многопоточные действия. На данный момент это ограничено удалением объектов в фоновом режиме и блокировкой команд, реализованных через модули Redis. В последующих выпусках планируется сделать Redis все более и более многопоточным.

## Какое максимальное количество ключей может содержать один экземпляр Redis? Каково максимальное количество элементов в Hash, List, Set, и Sorted Set?

Redis может обрабатывать до 2^32 ключей и на практике было протестировано
для обработки не менее 250 миллионов ключей на экземпляр.

Каждый hash, list, set, и sorted set, могут содержать 2^32 элементов.

Другими словами, вашим пределом вероятно является доступная память в вашей системе.

## Почему у моей реплики другое количество ключей, чем у главного экземпляра?

Если вы используете ключи с ограниченным сроком жизни (Redis expires), то это нормальное поведение. Вот что происходит:

* Главный сервер создает файл RDB при первой синхронизации с репликой.
* Файл RDB не будет включать ключи, срок действия которых уже истек в главном сервере, но которые все еще находятся в памяти.
* Эти ключи все еще находятся в памяти первичного Redis, даже если логически истек срок их действия. Они будут считаться несуществующими, а их память будет восстановлена позже либо постепенно, либо явным образом при доступе. Хотя эти ключи логически не являются частью набора данных, они учитываются в выводе `INFO` и при выполнении команды `DBSIZE`.
* Когда реплика считывает файл RDB, сгенерированный главным сервером, этот набор ключей не загружается.

Из-за этого пользователи со многими ключами с истекшим сроком действия часто видят меньше ключей в репликах. Однако, логически, главный сервер и реплика будут иметь одинаковый контент.

## Откуда взялось название "Redis"?

Redis это акроним от **RE**mote **DI**ctionary **S**erver.

## Почему Сальваторе Санфилиппо(Salvatore Sanfilippo) начал проект Redis?

Первоначально Сальваторе(Salvatore) создал Redis для масштабирования [LLOOGG](https://github.com/antirez/lloogg), инструмента анализа журналов в реальном времени. Но после того, как базовый сервер Redis заработал, он решил поделиться работой с другими людьми и превратить Redis в проект с открытым исходным кодом.

## Как произносится Redis?

"Redis" (/ˈrɛd-ɪs/) произносится как слово "red" плюс слово "kiss" без буквы "k".
